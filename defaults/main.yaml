cluster_spec_file: /tmp/{{ clusterSpec.cluster_name }}-cluster-spec.yaml
vpc_cfn_template_file: /tmp/{{ clusterSpec.cluster_name }}-vpc-cfn.yaml
ssh_public_key_file: /tmp/{{ clusterSpec.cluster_name }}-ssh-public-key
kops_log_file: /tmp/{{ clusterSpec.cluster_name }}-kops-out.log

defaultClusterSpec:
  create_bastions: false
  attach_transit_vpc: false
  createDNSForwarders: false
  vpcPeeringCidrs: []
  dnsForwarderInstanceType: r4.large
  dnsForwaderImageName: amzn-ami-hvm-2018.03.0.20180811-x86_64-gp2
  dnsForwaderImageOwner: '137112412989'
  kubeScheduler: {}
  kubeDNS: {}
  enableEtcdTLS: false
  etcdVersion:
  kubeAPIServer:
    runtimeConfig:
      batch/v2alpha1: "true"
  kubelet:
    enableCustomMetrics: true
  kubeControllerManager:
    horizontalPodAutoscalerUseRestClients: true
  api:
    loadBalancer:
      type: Internal
      idleTimeoutSeconds: 300
      additionalSecurityGroups: []
  authorization:
    rbac: {}
  channel: stable
  cloudLabels: {}
  cloudProvider: aws
  kubernetesApiAccess:
  - 0.0.0.0/0
  hooks: []
  fileAssets: []
  assets: {}
  cloudConfig: {}
  docker: {}
  iam:
    allowContainerRegistry: true
    legacy: false
  kubernetesVersion: 1.10.7
  nonMasqueradeCIDR: 100.64.0.0/10
  networking:
    calico: {}
  sshAccess:
  - 0.0.0.0/0
  additionalPolicies:
    node: |
      [
        {
          "Action": [
            "sts:AssumeRole"
          ],
          "Effect": "Allow",
          "Resource": "*"
        }
      ]
    master: |
      [
        {
          "Action": [
            "sts:AssumeRole"
          ],
          "Effect": "Allow",
          "Resource": "*"
        }
      ]

  defaultInstanceGroupSpec:
    image: kope.io/k8s-1.9-debian-jessie-amd64-hvm-ebs-2018-03-11
    autoScalerEnabled: true
    machineType: t2.micro

  instanceGroups:
    masters:
      machineType: t2.medium
      rootVolumeSize: 50
    bastions:
      machineType: t2.micro

  awsSideAsn: '65532'
  vpcStackPrefix: 'k8s-vpc-'

  clusterAddons:
    kube2iam:
      enabled: true
      chart: stable/kube2iam
      chart_version: '0.9.0'
      namespace: kube-system
      values:
        tolerations:
        - key: CriticalAddonsOnly
          operator: Exists
        - effect: NoExecute
          operator: Exists
        - effect: NoSchedule
          operator: Exists
        extraArgs:
          auto-discover-default-role:
        host:
          iptables: true
          interface: cali+
        rbac:
          create: true

    cluster-autoscaler:
      enabled: true
      chart: stable/cluster-autoscaler
      chart_version: '0.7.0'
      namespace: kube-system
      values:
        awsRegion: '{{ clusterSpec.aws_region }}'
        cloudProvider: aws
        autoDiscovery:
          clusterName: '{{ clusterSpec.cluster_name }}'
        rbac:
          create: true
        podAnnotations:
          iam.amazonaws.com/role: k8s-cluster-autoscaler-{{ clusterSpec.cluster_name }}

    metrics-server:
      enabled: true
      chart: stable/metrics-server
      chart_version: '2.0.2'
      namespace: kube-system
      values:
        rbac:
          create: true

    external-dns:
      enabled: true
      chart: 'stable/external-dns'
      chart_version: '0.7.5'
      namespace: kube-system
      values:
        aws:
          provider: 'aws'
          region: '{{ clusterSpec.aws_region }}'
        policy: sync
        rbac:
          create: true
        podAnnotations:
          iam.amazonaws.com/role: k8s-external-dns-{{ clusterSpec.cluster_name }}

    alb-ingress:
      enabled: true
      chart: '{{ role_path }}/patched-addon-charts/alb-ingress-controller'
      namespace: kube-system
      values:
        clusterName: '{{ clusterSpec.cluster_name }}'
        awsRegion: '{{ clusterSpec.aws_region }}'
        podAnnotations:
          iam.amazonaws.com/role: k8s-aws-alb-ingress-controller-{{ clusterSpec.cluster_name }}
        livenessProbeInitialDelay: 300


  kubernetesDashboardTemplate:
    chart: '{{ role_path }}/patched-addon-charts/kubernetes-dashboard'
    namespace: kube-system
    values:
      extraArgs:
        - --enable-insecure-login
      rbac:
        create: true
      exposeHTTPs: false
      ingress:
        annotations:
          ingress.kubernetes.io/force-ssl-redirect: "true"
          kubernetes.io/ingress.allow-http: "false"
          kubernetes.io/ingress.class: nginx-internal
      service:
        externalPort: 80

  kubernetesDashboard:
    enabled: false

  nginxIngressTemplate:
    chart: stable/nginx-ingress
    namespace: 'nginx-ingress'
    values:
      rbac:
        create: true
      controller:
        kind: DaemonSet
        minAvailable: 0
        config:
          server-snippet: |
            if ($http_x_forwarded_proto = 'http'){
                return 301 https://$host$request_uri;
            }
        publishService:
          enabled: true
        service:
          targetPorts:
            http: http
            https: http
          annotations:
            service.beta.kubernetes.io/aws-load-balancer-backend-protocol: "http"
            service.beta.kubernetes.io/aws-load-balancer-ssl-ports: "https"
            service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout: '3600'
